#include <amxmodx>
#include <engine>

#define PLUGIN "AutoMonsterSpawn" 
#define VERSION "1.2c"
#define AUTHOR "mlibre"

new Array:monster_names, loaded_monster

new mp_round_restart_delay

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	register_cvar(PLUGIN, VERSION, FCVAR_SERVER | FCVAR_SPONLY)
	
	monster_names = ArrayCreate(15)
	
	register_logevent("logevent_round_start", 2, "1=Round_Start")
	register_logevent("logevent_round_end", 2, "1=Round_End")
}

public plugin_end() ArrayDestroy(monster_names)

public plugin_cfg()
{
	if( !cvar_exists("monster_spawn") )
	{
		monster_fail("monster module")
	}
	
	new monster_cfg[] = "monster_precache.cfg"
	
	if(file_exists(monster_cfg))
	{
		new monster_supported_linux[][] =
		{
			"agrunt", "apache", "barney", "bigmomma", "bullsquid", "controller", 
			"hassassin", "headcrab", "hgrunt", "houndeye", "islave", "scientist", 
			"snark", "zombie"
		},
		monster_supported_windows[][] =
		{
			"agrunt", "apache", "barnacle", "barney", "bigmomma", "bloater", 
			"bullsquid", "controller", "gargantua", "babygarg", "gman", "hassassin", 
			"headcrab", "hgrunt", "houndeye", "ichthyosaur", "islave", "leech", 
			"scientist", "snark", "tentacle", "zombie", "rat", "roach", "gonome", 
			"massn", "otis", "gruntcmdr", "barneydead", "hgruntdead"
		}
		
		new file = fopen(monster_cfg, "rt"), output[15], os = is_linux_server()
		
		if( !file )
		{
			monster_fail(monster_cfg)
		}
		
		while(fgets(file, output, charsmax(output)))
		{
			trim(output)
			
			if( !output[0] 
			|| output[0] == ' ' 
			|| output[0] == '/' 
			|| output[0] == EOS 
			|| output[0] == ';' )
			{
				continue
			}
			
			for(new i; i < os ? sizeof monster_supported_linux : sizeof monster_supported_windows; i++)
			{
				if(equal(output, os ? monster_supported_linux[i] : monster_supported_windows[i]))
				{
					ArrayPushString(monster_names, output)
						
					break
				}
			}
		}
		
		fclose(file)
		
		loaded_monster = ArraySize(monster_names)
		
		if( !loaded_monster )
		{
			monster_fail("monster names")
		}
	}
	else
	{
		monster_fail(monster_cfg)
	}
	
	mp_round_restart_delay = get_cvar_pointer("mp_round_restart_delay")
}

public logevent_round_start()
{
	new players[32], num, selected_monster[15]; get_players(players, num, "ach")
	
	if( !num )
		return
		
	ArrayGetString(monster_names, random(loaded_monster), selected_monster, charsmax(selected_monster))
	
	set_hudmessage(255, 0, 0, -1.0, -1.0, 0, 6.0, 5.0)
	show_hudmessage(0, ":: Monster Spawned ::^n%s", selected_monster)
	
	//Warning: Do not enable too many monsters, or else your server may crash!
	server_cmd("monster %s #%d", selected_monster, players[random(num)])
}

public logevent_round_end()
{
	if(get_pcvar_num(mp_round_restart_delay) < 2)
	{
		set_pcvar_num(mp_round_restart_delay, 2)
	}
	
	//We prevent the permanence of the sprites generated by some monsters.
	set_task(1.0, "remove_monster")
}

public remove_monster()
{
	new func_monster[] = "func_wall", monster = find_ent_by_class(-1, func_monster)
	
	while(monster > 0)
	{
		if(entity_get_int(monster, EV_INT_flags) & FL_MONSTER)
		{
			entity_set_int(monster, EV_INT_flags, FL_KILLME)
			
			monster = find_ent_by_class(-1, func_monster)
		}
		else
		{
			monster = find_ent_by_class(monster, func_monster)
		}
	}
}

stock monster_fail(str[])
{
	#if AMXX_VERSION_NUM <= 182
	new sfs[64]; formatex(sfs, charsmax(sfs), "%s not loaded...", str)
	
	set_fail_state(sfs)
	#else
	set_fail_state("%s not loaded...", str)
	#endif
}
